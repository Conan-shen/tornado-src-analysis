## IO多路复用（Reactor）

   IO多路复用技术是为实现单线程处理多请求连接，减少系统因频繁的创建线程或进程而产生的资源消耗，这里的复用特指同时使用单一线程。linux下的select、poll、epoll为IO多路复用的具体实现。当客户端与服务端的socket连接建立之后，程序将该socket文件描述符注册到epoll，然后返回，最终交由epoll去管理。epoll可以同时监听多个文件描述符，当某个或某些文件描述符就绪，则通知程序进行相应的读写操作，否则会一直阻塞知道有文件描述符就绪。我们使用epoll编程时，会设置socket非阻塞模式。所以，IO多路复用是同步非阻塞IO。

* select、poll、epoll比较

    * select
    
        select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。

        select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。

        缺点：

        * 每次调用select都需要把文件描述符（FD）从用户态拷贝到内核，开销比较大
        * 每次都需要在内核遍历传入的文件描述符（FD）
        * select支持文件数量比较小，默认是1024。当然，也可以通过修改宏定义改掉，但这会造成效率的降低。

    * poll
    
        poll及轮训，poll和select本质上是一样的，只是描述fd集合的方式不同。poll使用的是pollfd结构，select使用的是fd_set结构。

    * epoll
        
        epoll是对select和poll的改进，而且改正了select、poll的三个缺点和不足。

        相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。

        优点：

        * 每次注册新事件到epoll句柄都会把所有的fd拷贝进来，而不是在epoll_wait中重复拷贝，这样确保fd只会被拷贝一次
        * epoll不是像select/poll那样每次都把fd加入等待队列，epoll把每个fd指定一个回调函数，当设备就绪时，唤醒等待队列的等待者就会调用其它的回调函数，这个回调函数会把就绪的fd放入一个就绪链表。epoll_wait就是在这个就绪链表中查看有没有就绪fd。
        * epoll没有fd数目限制
        
        缺点：

        * 如果没有大量的idle-connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle-connection，就会发现epoll的效率大大高于select/poll。
            
    * 总结：
        
        * select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用 epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在 epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的 时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。
        * select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要 一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内 部定义的等待队列）。这也能节省不少的开销。
